import browserslist from 'browserslist';
import postcss from 'postcss';

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var index = postcss.plugin('postcss-browser-comments', opts => root => {
  // client browserslist
  const clientBrowserList = browserslist(Object(opts).browsers || null, {
    path: root.source && root.source.input && root.source.input.file
  }); // root children references

  const references = root.nodes.slice(0); // for each child node of the root children references

  var _iterator = _createForOfIteratorHelper(references),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      let node = _step.value;

      // if the node is a comment browser comment node
      if (isBrowserCommentNode(node)) {
        // rule following the browser comment
        const rule = node.next(); // browser data

        const browserdata = getBrowserData(node.text);

        if (browserdata.isNumbered) {
          rule.nodes.filter(isBrowserReferenceCommentNode).map(comment => {
            const browserdataIndex = parseFloat(comment.text) - 1;
            const browserslistPart = browserdata.browserslist[browserdataIndex]; // whether to remove the rule if the comment browserslist does not match the client browserslist

            const removeRule = !clientBrowserList.some(clientBrowser => browserslist(browserslistPart).some(commentBrowser => commentBrowser === clientBrowser)); // conditionally remove the declaration and reference comment

            if (removeRule) {
              comment.prev().remove();
              comment.remove();
            }
          }); // conditionally remove the empty rule and comment

          if (!rule.nodes.length) {
            rule.remove();
            node.remove();
          }
        } else {
          // whether to remove the rule if the comment browserslist does not match the client browserslist
          const removeRule = !clientBrowserList.some(clientBrowser => browserslist(browserdata.browserslist).some(commentBrowser => commentBrowser === clientBrowser)); // conditionally remove the rule and comment

          if (removeRule) {
            rule.remove();
            node.remove();
          }
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}); // returns whether a node is a browser comment

const isBrowserCommentNode = node => node.type === 'comment' && isBrowserCommentNodeRegExp.test(node.text) && node.next().type === 'rule';

const isBrowserCommentNodeRegExp = /^\*\n * /; // returns whether a node is a browser reference comment

const isBrowserReferenceCommentNode = node => node.type === 'comment' && isBrowserReferenceCommentNodeRegExp.test(node.text);

const isBrowserReferenceCommentNodeRegExp = /^\d+$/; // returns browser data from comment text

const getBrowserData = text => {
  const browserDataNumbered = text.match(browserDataMutliRegExp);
  const isNumbered = Boolean(browserDataNumbered);
  return {
    browserslist: isNumbered ? browserDataNumbered.map(browserslistPart => getBrowsersList(browserslistPart.replace(browserDataNumberedNewlineRegExp, '$1'))) : getBrowsersList(text.replace(browserDataNewlineRegExp, '')),
    isNumbered
  };
};

const browserDataMutliRegExp = /(\n \* \d+\. (?:[^\n]+|\n \* {4,})+)/g;
const browserDataNewlineRegExp = /^\*\n \* ?|\n \*/g;
const browserDataNumberedNewlineRegExp = /\n \* (?:( )\s*)?/g; // returns a browserlist from comment text

const getBrowsersList = text => text.split(getBrowsersListInSplitRegExp).slice(1).map(part => part.split(getBrowsersListAndSplitRegExp).filter(part2 => part2)).reduce((acc, val) => acc.concat(val), []).map(part => part.replace(getBrowsersListQueryRegExp, ($0, browser, query) => browser === 'all' ? '> 0%' : `${browser}${query ? /^((?:\d*\.)?\d+)-$/.test(query) ? ` <= ${query.slice(0, -1)}` : ` ${query}` : ' > 0'}`).toLowerCase());

const getBrowsersListInSplitRegExp = /\s+in\s+/;
const getBrowsersListAndSplitRegExp = /(?: and|, and|,)/;
const getBrowsersListQueryRegExp = /^\s*(\w+)(?: ((?:(?:\d*\.)?\d+-)?(?:\d*\.)?\d+[+-]?))?.*$/;

export default index;
